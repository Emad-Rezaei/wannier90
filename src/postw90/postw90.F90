!-*- mode: F90 -*-!
!------------------------------------------------------------!
! This file is distributed as part of the Wannier90 code and !
! under the terms of the GNU General Public License. See the !
! file `LICENSE' in the root directory of the Wannier90      !
! distribution, or http://www.gnu.org/copyleft/gpl.txt       !
!                                                            !
! The webpage of the Wannier90 code is www.wannier.org       !
!                                                            !
! The Wannier90 code is hosted on GitHub:                    !
!                                                            !
! https://github.com/wannier-developers/wannier90            !
!------------------------------------------------------------!

program postw90
  !! The postw90 program
  use w90_constants, only: dp, eps6, pw90_physical_constants
  use w90_parameters
  use pw90_parameters
  use w90_param_methods, only: param_read_chkpt, param_write_header
  use pw90_param_methods
  use w90_io

  use w90_kmesh
  use w90_comms, only: comms_setup, comms_end, comms_bcast, comms_barrier, w90commtype, mpirank, &
    mpisize
  use w90_postw90_common, only: pw90common_wanint_setup, pw90common_wanint_get_kpoint_file, &
    pw90common_wanint_param_dist, pw90common_wanint_data_dist, cell_volume

  ! These modules deal with the interpolation of specific physical properties
  !
  use w90_dos
  use w90_berry
  use w90_gyrotropic
  use w90_spin
  use w90_kpath
  use w90_kslice

  use w90_boltzwann
  use w90_geninterp

  implicit none

  type(pw90_physical_constants) :: physics
  integer       :: nkp, len_seedname
  integer       :: stdout
  character(len=50) :: seedname
  logical       :: have_gamma
  real(kind=dp) :: time0, time1, time2
  character(len=9) :: stat, pos
  logical :: wpout_found, werr_found, dryrun
  character(len=50) :: prog
  character(len=20) :: checkpoint
  ! this is a dummy that is not used in postw90, DO NOT use
  complex(kind=dp), allocatable :: m_matrix(:, :, :, :)
  logical :: on_root = .false.
  integer :: my_node_id, num_nodes

  ! this can't work -- stdout and seedname aren't defined yet --FIXME JJ
  call comms_setup(stdout, seedname, world)

  my_node_id = mpirank(world)
  num_nodes = mpisize(world)

  if (my_node_id == 0) on_root = .true.

  if (on_root) then
    time0 = io_time()
    prog = 'postw90'
    call io_commandline(prog, dryrun, seedname)
    len_seedname = len(seedname)
  end if
  call comms_bcast(len_seedname, 1, stdout, seedname, world)
  call comms_bcast(seedname, len_seedname, stdout, seedname, world)
  call comms_bcast(dryrun, 1, stdout, seedname, world)

  if (on_root) then
    ! If an error file (generated by postw90) exists, I delete it
    ! Note: I do it only for the error file generated from the root node;
    ! If error files generated by other nodes exist, I don't do anything for them
    inquire (file=trim(seedname)//'.node_00000.werr', exist=werr_found)
    if (werr_found) then
      stdout = io_file_unit()
      open (unit=stdout, file=trim(seedname)//'.node_00000.werr', status='old', position='append')
      close (stdout, status='delete')
    end if

    inquire (file=trim(seedname)//'.wpout', exist=wpout_found)
    if (wpout_found) then
      stat = 'old'
    else
      stat = 'replace'
    endif
    pos = 'append'

    stdout = io_file_unit()
    open (unit=stdout, file=trim(seedname)//'.wpout', status=trim(stat), position=trim(pos))

    call param_write_header(physics%bohr_version_str, physics%constants_version_str1, &
                            physics%constants_version_str2, stdout)
    if (num_nodes == 1) then
#ifdef MPI
      write (stdout, '(/,1x,a)') 'Running in serial (with parallel executable)'
#else
      write (stdout, '(/,1x,a)') 'Running in serial (with serial executable)'
#endif
    else
      write (stdout, '(/,1x,a,i3,a/)') &
        'Running in parallel on ', num_nodes, ' CPUs'
    endif
  end if

  ! Read onto the root node all the input parameters from seendame.win,
  ! as well as the energy eigenvalues on the ab-initio q-mesh from seedname.eig
  !
  if (on_root) then
    call param_postw90_read(param_input, wann_data, kmesh_data, k_points, num_kpts, &
                            dis_data, fermi, atoms, num_bands, num_wann, eigval, &
                            mp_grid, real_lattice, recip_lattice, spec_points, &
                            pw90_calcs, postw90_oper, pw90_common, pw90_spin, &
                            pw90_ham, kpath, kslice, dos_data, berry, &
                            spin_hall, gyrotropic, geninterp, boltz, eig_found, physics%bohr, stdout, seedname)
    cell_volume = real_lattice(1, 1)*(real_lattice(2, 2)*real_lattice(3, 3) - real_lattice(3, 2)*real_lattice(2, 3)) + &
                  real_lattice(1, 2)*(real_lattice(2, 3)*real_lattice(3, 1) - real_lattice(3, 3)*real_lattice(2, 1)) + &
                  real_lattice(1, 3)*(real_lattice(2, 1)*real_lattice(3, 2) - real_lattice(3, 1)*real_lattice(2, 2))
    call param_postw90_write(param_input, fermi, atoms, num_wann, &
                             real_lattice, recip_lattice, spec_points, &
                             pw90_calcs, postw90_oper, pw90_common, &
                             pw90_spin, kpath, kslice, dos_data, berry, &
                             gyrotropic, geninterp, boltz, stdout)
    time1 = io_time()
    write (stdout, '(1x,a25,f11.3,a)') &
      'Time to read parameters  ', time1 - time0, ' (sec)'

    if (.not. pw90_common%effective_model) then
      ! Check if the q-mesh includes the gamma point
      !
      have_gamma = .false.
      do nkp = 1, num_kpts
        if (all(abs(k_points%kpt_latt(:, nkp)) < eps6)) have_gamma = .true.
      end do
      if (.not. have_gamma) write (stdout, '(1x,a)') &
        'Ab-initio does not include Gamma. Interpolation may be incorrect!!!'
      !
      ! Need nntot, wb, and bk to evaluate WF matrix elements of
      ! the position operator in reciprocal space. Also need
      ! nnlist to compute the additional matrix elements entering
      ! the orbital magnetization
      !
      call kmesh_get(recip_lattice, k_points%kpt_cart, param_input, kmesh_info, &
                     kmesh_data, &
                     num_kpts, stdout, seedname)

      time2 = io_time()
      write (stdout, '(1x,a25,f11.3,a)') &
        'Time to get kmesh        ', time2 - time1, ' (sec)'
    endif

    ! GP, May 10, 2012: for the moment I leave this commented
    ! since we need first to tune that routine so that it doesn't
    ! print the memory information related to wannier90.x.
    ! Note that the code for the memory estimation for the
    ! Boltzwann routine is already there.
    !       call param_memory_estimate
  end if

  if (dryrun) then
    if (on_root) then
      write (stdout, *) ' '
      write (stdout, *) '                       ==============================='
      write (stdout, *) '                                   DRYRUN             '
      write (stdout, *) '                       No problems found with win file'
      write (stdout, *) '                       ==============================='
    endif
    stop
  endif

  ! We now distribute a subset of the parameters to the other nodes
  !
  call pw90common_wanint_param_dist(stdout, seedname)

  if (.not. pw90_common%effective_model) then
    !
    ! Read files seedname.chk (overlap matrices, unitary matrices for
    ! both disentanglement and maximal localization, etc.)
    !
    if (on_root) then
      call param_read_chkpt(checkpoint, param_input, wann_data, kmesh_info, &
                            k_points, num_kpts, dis_data, num_bands, &
                            num_wann, u_matrix, u_matrix_opt, m_matrix, &
                            mp_grid, real_lattice, recip_lattice, .true., stdout, seedname)
    endif
    !
    ! Distribute the information in the um and chk files to the other nodes
    !
    ! Ivo: For interpolation purposes we do not need u_matrix_opt and
    !      u_matrix separately, only their product v_matrix, and this
    !      is what is distributed now
    !
    call pw90common_wanint_data_dist(stdout, seedname)
    !
  end if

  ! Read list of k-points in irreducible BZ and their weights
  !
  ! Should this be done on root node only?
  !
  if (berry%wanint_kpoint_file) call pw90common_wanint_get_kpoint_file(stdout, seedname)

  ! Setup a number of common variables for all interpolation tasks
  !
  call pw90common_wanint_setup(stdout, seedname)

  if (on_root) then
    time1 = io_time()
    write (stdout, '(/1x,a25,f11.3,a)') &
      'Time to read and process .chk    ', time1 - time2, ' (sec)'
  endif
  !
  ! Now perform one or more of the following tasks

  ! ---------------------------------------------------------------
  ! Density of states calculated using a uniform interpolation mesh
  ! ---------------------------------------------------------------
  !
  if (pw90_calcs%dos .and. index(dos_data%task, 'dos_plot') > 0) call dos_main(stdout, seedname)

! find_fermi_level commented for the moment in dos.F90
!  if(dos .and. index(dos_task,'find_fermi_energy')>0) call find_fermi_level

  ! --------------------------------------------------------------------
  ! Bands, Berry curvature, or orbital magnetization plot along a k-path
  ! --------------------------------------------------------------------
  !
  if (pw90_calcs%kpath) call k_path(physics%bohr, stdout, seedname)

  ! ---------------------------------------------------------------------------
  ! Bands, Berry curvature, or orbital magnetization plot on a slice in k-space
  ! ---------------------------------------------------------------------------
  !
  if (pw90_calcs%kslice) call k_slice(physics%bohr, stdout, seedname)

  ! --------------------
  ! Spin magnetic moment
  ! --------------------
  !
  if (pw90_common%spin_moment) call spin_get_moment(param_input%iprint, stdout, seedname)

  ! -------------------------------------------------------------------
  ! dc Anomalous Hall conductivity and eventually (if 'mcd' string also
  ! present in addition to 'ahe', e.g., 'ahe+mcd') dichroic optical
  ! conductivity, both calculated on the same (adaptively-refined) mesh
  ! -------------------------------------------------------------------
  !
  ! ---------------------------------------------------------------
  ! Absorptive dichroic optical conductivity & JDOS on uniform mesh
  ! ---------------------------------------------------------------
  !
  ! -----------------------------------------------------------------
  ! Absorptive ordinary optical conductivity & JDOS on a uniform mesh
  ! -----------------------------------------------------------------
  !
  ! -----------------------------------------------------------------
  ! Orbital magnetization
  ! -----------------------------------------------------------------
  !
  if (pw90_calcs%berry) call berry_main(param_input, fermi, num_wann, berry, pw90_common, &
                                        spin_hall, physics, stdout, seedname, world)
  ! -----------------------------------------------------------------
  ! Boltzmann transport coefficients (BoltzWann module)
  ! -----------------------------------------------------------------
  !
  if (on_root) then
    time1 = io_time()
  endif

  if (pw90_calcs%geninterp) call geninterp_main(stdout, seedname)

  if (pw90_calcs%boltzwann) call boltzwann_main(physics, stdout, seedname)

  if (pw90_calcs%gyrotropic) call gyrotropic_main(physics, stdout, seedname)

  if (on_root .and. pw90_calcs%boltzwann) then
    time2 = io_time()
    write (stdout, '(/1x,a,f11.3,a)') &
      'Time for BoltzWann (Boltzmann transport) ', time2 - time1, ' (sec)'
  endif

  ! I put a barrier here before calling the final time printing routines,
  ! just to be sure that all processes have arrived here.
  call comms_barrier(world)
  if (on_root) then
    write (stdout, '(/,1x,a25,f11.3,a)') &
      'Total Execution Time     ', io_time(), ' (sec)'
    if (param_input%timing_level > 0) call io_print_timings(stdout)
    write (stdout, *)
    write (stdout, '(/,1x,a)') 'All done: postw90 exiting'
    close (stdout)
  end if

  call comms_end

end program postw90

